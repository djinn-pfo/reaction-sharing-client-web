import React, { useEffect, useState, useRef, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button } from '../common/Button';
import { LoadingSpinner } from '../common/LoadingSpinner';
import { useSignaling } from '../../hooks/useSignaling';
import { useMediaPipe } from '../../hooks/useMediaPipe';
import { IntensityChart } from '../charts/IntensityChart';
import { NormalizedLandmarksViewer } from '../visualization/NormalizedLandmarksViewer';
import { BroadcastTimestampSync, ReactionReceiver } from '../../services/broadcast';
import { ViewerReactionSender } from '../../services/viewer';
import { IonSfuService } from '../../services/ionSfu/IonSfuService';
import { AuthService } from '../../services/auth/AuthService';
import type { BroadcastTimestampMessage, EmotionWithTimestampMessage } from '../../types/signaling';
import type { ReceivedReactionWithMetrics } from '../../types/broadcast';

export const SessionView: React.FC = () => {
  const { roomId } = useParams();
  const navigate = useNavigate();
  const [isJoining, setIsJoining] = useState(false);
  const [joinError, setJoinError] = useState<string | null>(null);
  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);
  const viewerCameraRef = useRef<HTMLVideoElement>(null); // 視聴者用カメラ（MediaPipe処理用）
  const animationFrameRef = useRef<number | undefined>(undefined);
  const initializedRoomRef = useRef<string | null>(null);
  const cancelledRef = useRef<boolean>(false);

  // Broadcast/Viewer role state
  const [isBroadcaster, setIsBroadcaster] = useState<boolean | undefined>(undefined);
  const [hasTimestamp, setHasTimestamp] = useState(false);
  const [receivedReactions, setReceivedReactions] = useState<ReceivedReactionWithMetrics[]>([]);
  const [peersToConnect, setPeersToConnect] = useState<string[]>([]);
  const [broadcasterUserId, setBroadcasterUserId] = useState<string>('broadcaster');
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  // Broadcast services
  const timestampSyncRef = useRef<BroadcastTimestampSync | null>(null);
  const reactionReceiverRef = useRef<ReactionReceiver | null>(null);
  const viewerReactionSenderRef = useRef<ViewerReactionSender | null>(null);
  const ionSfuServiceRef = useRef<IonSfuService | null>(null);
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);

  // ユーザー名を取得
  const userName = localStorage.getItem('userName') || 'Anonymous';

  // Debug: Monitor isBroadcaster state changes
  useEffect(() => {
    console.log('[SessionView] 🔄 isBroadcaster state changed:', isBroadcaster);
  }, [isBroadcaster]);

  // Handle broadcast timestamp (for viewers)
  const handleBroadcastTimestamp = useCallback((message: BroadcastTimestampMessage) => {
    console.log('[SessionView] Received broadcast timestamp:', message);

    // 配信者のIDを保存
    if (message.from) {
      setBroadcasterUserId(message.from);
    }

    if (viewerReactionSenderRef.current) {
      viewerReactionSenderRef.current.handleBroadcastTimestamp(message);
      setHasTimestamp(true);
    }
  }, []);

  // Handle emotion with timestamp (for broadcaster)
  const handleEmotionWithTimestamp = useCallback((message: EmotionWithTimestampMessage) => {
    console.log('[SessionView] Received emotion with timestamp:', message);
    if (reactionReceiverRef.current) {
      reactionReceiverRef.current.handleReactionWithMetrics(message);
    }
  }, []);

  const {
    connectionState,
    isConnected,
    error: signalingError,
    receivedEmotions,
    connect,
    joinRoom,
    leaveRoom,
    sendEmotionData,
    sendBroadcastTimestamp,
    sendEmotionWithTimestamp,
    getWebSocketState,
  } = useSignaling({
    enableWebRTC: false, // WebRTC now handled by Ion-SFU
    onBroadcastTimestamp: handleBroadcastTimestamp,
    onEmotionWithTimestamp: handleEmotionWithTimestamp,
    onRoomJoined: useCallback((message: any) => {
      console.log('[SessionView] 🎯 Room joined message received:', message);

      // バックエンドから直接role情報を取得
      const isBroadcasterRole = message.data?.isBroadcaster ?? false;
      const role = message.data?.role;
      const participantNumber = message.data?.participantNumber;
      const participantCount = message.data?.participantCount;
      const userId = message.data?.userId || message.userId;

      console.log('[SessionView] 📊 Role determination from backend:', {
        isBroadcaster: isBroadcasterRole,
        role,
        participantNumber,
        participantCount,
        userId,
        messageFrom: message.from
      });

      console.log(`[SessionView] 🎬 Setting isBroadcaster to: ${isBroadcasterRole}`);
      setIsBroadcaster(isBroadcasterRole);
    }, []),
  });

  // MediaPipe感情検出（ランドマーク送信機能付き）
  const {
    isInitialized: isMediaPipeReady,
    landmarks,
    normalizedLandmarks,
    normalizationData,
    processVideoFrame,
    error: mediaPipeError
  } = useMediaPipe({
    sendInterval: 33, // 30fps = 33ms間隔
    enableSending: true // WebSocket送信有効
  });

  // ランドマーク送信コールバック（WebSocket経由）
  const lastSendTimeRef = useRef<number>(0);
  const lastReactionSendTimeRef = useRef<number>(0);
  const handleLandmarkData = useCallback((landmarks: any[]) => {
    const now = Date.now();
    const sendInterval = 33; // 33ms間隔（約30FPS）で送信
    const reactionSendInterval = 100; // 100ms間隔（10Hz）でリアクション送信

    // 送信頻度制限
    if (now - lastSendTimeRef.current < sendInterval) {
      return;
    }

    // 視聴者の場合のみ: リアクションを送信
    if (!isBroadcaster && isConnected && landmarks.length > 0) {
      // 通常の感情データ送信
      const success = sendEmotionData(normalizedLandmarks || landmarks, userName, 0.9);
      if (success) {
        lastSendTimeRef.current = now;
        const landmarkCount = normalizedLandmarks?.length || landmarks.length;
        const isNormalized = !!normalizedLandmarks;
        console.log(`📤 Viewer sent emotion data: ${landmarkCount} landmarks (normalized: ${isNormalized})`);
      }

      // タイムスタンプ付きリアクション送信
      if (viewerReactionSenderRef.current && hasTimestamp) {
        if (now - lastReactionSendTimeRef.current >= reactionSendInterval) {
          // 簡易的な感情強度計算（実際はバックエンドで計算）
          const intensity = Math.floor(Math.random() * 100);
          const confidence = 0.9;

          const reactionSuccess = viewerReactionSenderRef.current.sendReactionWithTimestamp(intensity, confidence);
          if (reactionSuccess) {
            lastReactionSendTimeRef.current = now;
            console.log('[SessionView] Viewer: Sent reaction');
          }
        }
      }
    } else if (isBroadcaster) {
      // 配信者は感情データを送信しない（タイムスタンプのみ送信）
      console.log('📡 Broadcaster: Skip sending emotion data (timestamp only)');
    }
  }, [isConnected, sendEmotionData, normalizedLandmarks, normalizationData, isBroadcaster, hasTimestamp, userName]);

  // 感情データの状態管理は削除（インジケーター非表示のため）

  // 感情検出のアニメーションループ（制限付き）
  useEffect(() => {
    let lastProcessTime = 0;
    const targetFPS = 30; // 30FPSに制限
    const frameInterval = 1000 / targetFPS;

    const processEmotion = () => {
      const now = performance.now();

      if (now - lastProcessTime >= frameInterval) {
        // 役割に応じて適切なビデオ要素を選択
        const videoElement = isBroadcaster ? localVideoRef.current : viewerCameraRef.current;

        if (videoElement && isMediaPipeReady && videoElement.readyState >= 2) {
          try {
            processVideoFrame(videoElement);

            // ランドマークが検出された場合、WebSocketで送信
            if (landmarks && landmarks.length > 0) {
              handleLandmarkData(landmarks);
            }
          } catch (error) {
            console.error('MediaPipe processing error:', error);
          }
        }
        lastProcessTime = now;
      }

      animationFrameRef.current = requestAnimationFrame(processEmotion);
    };

    if (isMediaPipeReady && localStream) {
      processEmotion();
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isMediaPipeReady, localStream, landmarks, processVideoFrame, handleLandmarkData, isBroadcaster]);

  // ビデオストリームをセットアップ
  useEffect(() => {
    console.log('[SessionView] Video setup check:', {
      hasVideoRef: !!localVideoRef.current,
      hasLocalStream: !!localStream,
      isBroadcaster,
      streamTracks: localStream?.getTracks().length || 0
    });

    if (localVideoRef.current && localStream) {
      localVideoRef.current.srcObject = localStream;
      localVideoRef.current.play().catch((error) => {
        console.log('Video autoplay failed, user interaction may be required:', error);
      });
      console.log('✅ Local video stream set and playing', {
        videoWidth: localVideoRef.current.videoWidth,
        videoHeight: localVideoRef.current.videoHeight,
        readyState: localVideoRef.current.readyState
      });
    }
  }, [localStream, isBroadcaster]);

  // 視聴者用のカメラストリームをセットアップ（MediaPipe処理用）
  useEffect(() => {
    if (!isBroadcaster && viewerCameraRef.current && localStream) {
      viewerCameraRef.current.srcObject = localStream;
      viewerCameraRef.current.play().catch((error) => {
        console.log('Viewer camera autoplay failed:', error);
      });
      console.log('✅ Viewer camera stream set for MediaPipe processing');
    }
  }, [isBroadcaster, localStream]);

  // 統合された初期化処理: 認証 → WebSocket → カメラ → ルーム参加 → Ion-SFU
  useEffect(() => {
    if (!roomId) {
      console.log('roomIdが無いため初期化をスキップ');
      return;
    }

    // 重複初期化を防ぐ
    if (initializedRoomRef.current === roomId && !cancelledRef.current) {
      console.log('🔄 初期化は既に実行済み - スキップ');
      return;
    }

    cancelledRef.current = false;
    initializedRoomRef.current = roomId;

    const initializeAll = async () => {
      console.log('🚀 統合初期化開始:', { roomId });
      setIsJoining(true);
      setJoinError(null);

      try {
        // ========== Step 1: 認証 ==========
        console.log('🔑 Step 1: Ensuring authentication...');
        await AuthService.ensureAuthenticated(userName);
        if (cancelledRef.current) return;
        setIsAuthenticated(true);
        console.log('✅ Authentication ready');

        // ========== Step 2: WebSocket接続 ==========
        console.log('🔌 Step 2: WebSocket connection...');
        if (connectionState === 'disconnected') {
          await connect();
          if (cancelledRef.current) return;
        }
        const connectionSuccess = await waitForConnection(15000);
        if (cancelledRef.current) return;
        if (!connectionSuccess) {
          throw new Error('WebSocket接続のタイムアウト');
        }
        console.log('✅ WebSocket connected');

        // ========== Step 3: カメラストリーム取得 ==========
        console.log('📹 Step 3: Getting camera stream...');
        let stream = localStream;
        if (!stream) {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
            audio: false,
          });
          if (cancelledRef.current) return;
          setLocalStream(stream);
        }
        console.log('✅ Camera stream ready');

        // ========== Step 4: ルーム参加 ==========
        console.log('🏠 Step 4: Joining room...');
        await joinRoom(roomId, userName);
        if (cancelledRef.current) return;
        console.log('✅ Room joined - waiting for role determination...');

        // 役割が決定されるまで待機
        // （onRoomJoined コールバックで setIsBroadcaster が呼ばれる）

      } catch (error) {
        if (!cancelledRef.current) {
          console.error('❌ 初期化エラー:', error);
          setJoinError(error instanceof Error ? error.message : '初期化に失敗しました');
        }
      } finally {
        if (!cancelledRef.current) {
          setIsJoining(false);
        }
      }
    };

    initializeAll();

    return () => {
      cancelledRef.current = true;
      console.log('🧹 Cleanup called');
      if (roomId && isConnected) {
        leaveRoom(roomId);
      }
      if (ionSfuServiceRef.current) {
        ionSfuServiceRef.current.cleanup();
        ionSfuServiceRef.current = null;
      }
      if (timestampSyncRef.current) {
        timestampSyncRef.current.stopPeriodicSync();
        timestampSyncRef.current = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    };
  }, [roomId]);

  // Ion-SFU初期化（役割決定後に実行）
  useEffect(() => {
    if (!roomId) return;
    if (isBroadcaster === undefined) {
      console.log('[Ion-SFU] ⏳ Waiting for role determination...');
      return;
    }
    if (!isAuthenticated) {
      console.log('[Ion-SFU] ⏳ Waiting for authentication...');
      return;
    }

    const initializeServices = async () => {
      if (isBroadcaster) {
        // Broadcaster: Initialize timestamp sync, reaction receiver, and Ion-SFU publish
        if (!timestampSyncRef.current) {
          console.log('[SessionView] Initializing broadcaster services...');

          timestampSyncRef.current = new BroadcastTimestampSync(
            roomId,
            userName,
            sendBroadcastTimestamp
          );

          reactionReceiverRef.current = new ReactionReceiver();
          reactionReceiverRef.current.setReactionCallback((reaction) => {
            console.log('[SessionView] Received reaction:', reaction);
            setReceivedReactions((prev) => [...prev, reaction].slice(-100));
          });

          timestampSyncRef.current.startPeriodicSync(50);
          console.log('[SessionView] Broadcaster services initialized');

          // Publish video stream via Ion-SFU
          if (localStream && !ionSfuServiceRef.current) {
            try {
              console.log('[SessionView] 📡 Starting Ion-SFU publish...');
              ionSfuServiceRef.current = new IonSfuService(roomId, userName);
              await ionSfuServiceRef.current.publish(localStream);
              console.log('[SessionView] ✅ Ion-SFU publish completed');
            } catch (error) {
              console.error('[SessionView] ❌ Ion-SFU publish failed:', error);
            }
          }
        }
      } else if (isBroadcaster === false) {
        // Viewer: Initialize reaction sender and Ion-SFU subscribe
        if (!viewerReactionSenderRef.current) {
          console.log('[SessionView] Initializing viewer services with broadcaster:', broadcasterUserId);

          viewerReactionSenderRef.current = new ViewerReactionSender(
            roomId,
            userName,
            broadcasterUserId,
            sendEmotionWithTimestamp
          );
          console.log('[SessionView] Viewer services initialized');

          // Subscribe to broadcaster's video stream via Ion-SFU
          if (!ionSfuServiceRef.current) {
            try {
              console.log('[SessionView] 📡 Starting Ion-SFU subscribe...');
              ionSfuServiceRef.current = new IonSfuService(roomId, userName);
              await ionSfuServiceRef.current.subscribe((remoteStream) => {
                console.log('[SessionView] 📺 Received remote stream from Ion-SFU');
                if (remoteVideoRef.current) {
                  remoteVideoRef.current.srcObject = remoteStream;
                  remoteVideoRef.current.play().catch((error) => {
                    console.log('Remote video autoplay failed:', error);
                  });
                }
              });
              console.log('[SessionView] ✅ Ion-SFU subscribe completed');
            } catch (error) {
              console.error('[SessionView] ❌ Ion-SFU subscribe failed:', error);
            }
          }
        }
      }
    };

    initializeServices();
  }, [isBroadcaster, roomId, userName, broadcasterUserId, localStream, sendBroadcastTimestamp, sendEmotionWithTimestamp, isAuthenticated]);

  // WebSocket接続完了を待機する関数
  const waitForConnection = useCallback(async (timeout = 5000): Promise<boolean> => {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const checkConnection = () => {
        // WebSocketClient の状態を直接チェック（stale closure を回避）
        const wsState = getWebSocketState();
        const reactState = { connectionState, isConnected };
        const isWsConnected = wsState === 'connected';
        const isReactConnected = connectionState === 'connected' || isConnected;

        console.log('🔄 接続待機中:', {
          wsState,
          isWsConnected,
          connectionState,
          isConnected,
          reactState,
          isReactConnected,
          timeElapsed: Date.now() - startTime
        });

        // WebSocketClient の状態を優先してチェック
        if (isWsConnected) {
          console.log('✅ 接続確認完了 (WebSocket state)');
          resolve(true);
          return;
        }

        if (Date.now() - startTime > timeout) {
          console.log('⏰ 接続待機タイムアウト');
          resolve(false);
          return;
        }

        setTimeout(checkConnection, 100);
      };
      checkConnection();
    });
  }, []); // 依存配列を空にして再作成を防ぐ

  // セッション初期化（WebSocket接続 + WebRTC）
  useEffect(() => {
    console.log('[useEffect] セッション初期化 useEffect triggered:', {
      roomId,
      initializedRoomRef: initializedRoomRef.current,
      cancelledRef: cancelledRef.current
    });

    if (!roomId) {
      console.log('[useEffect] roomIdが無いため初期化をスキップ');
      return;
    }

    // 条件チェックを一時的に無効化してテスト
    // if (initializedRoomRef.current === roomId && !cancelledRef.current) {
    //   console.log('🔄 初期化は既に実行済み - スキップ');
    //   return;
    // }

    console.log('[useEffect] 初期化処理を開始します');
    cancelledRef.current = false;
    initializedRoomRef.current = roomId;

    const initializeSession = async () => {
      console.log('🚀 セッション初期化開始:', { roomId, connectionState, isConnected });
      setIsJoining(true);
      setJoinError(null);

      try {
        // 0. 認証トークンを確保
        console.log('🔑 Ensuring authentication...');
        await AuthService.ensureAuthenticated(userName);
        if (cancelledRef.current) return;
        setIsAuthenticated(true);
        console.log('✅ Authentication ready');

        // 1. WebSocket接続
        console.log('🔍 Checking connection state:', connectionState);
        if (connectionState === 'disconnected') {
          console.log('🔌 WebSocket接続を開始...');
          await connect();
          if (cancelledRef.current) return;
          console.log('✅ WebSocket接続完了');
        } else {
          console.log('⏭️ WebSocket already connected or connecting, state:', connectionState);
        }

        // 接続完了を待機
        console.log('⏳ WebSocket接続完了を待機...');
        const connectionSuccess = await waitForConnection(15000); // 15秒に延長
        if (cancelledRef.current) return;
        if (!connectionSuccess) {
          console.log('❌ WebSocket接続タイムアウト - 現在の状態:', { connectionState, isConnected });
          throw new Error('WebSocket接続のタイムアウト');
        }

        // 2. カメラストリーム取得
        if (!localStream) {
          console.log('📹 カメラストリーム取得を開始...');
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
            audio: false,
          });
          if (cancelledRef.current) return;
          setLocalStream(stream);
          console.log('✅ カメラストリーム取得完了');
        }

        // 3. ルーム参加
        console.log('🏠 ルーム参加を開始...', { roomId, userName });
        await joinRoom(roomId, userName);
        if (cancelledRef.current) return;
        console.log('✅ ルーム参加完了 - 役割は room-joined メッセージで決定されます');

        console.log('セッション初期化完了');
      } catch (error) {
        if (!cancelledRef.current) {
          console.error('セッション初期化エラー:', error);
          setJoinError(error instanceof Error ? error.message : 'セッションの初期化に失敗しました');
        }
      } finally {
        if (!cancelledRef.current) {
          console.log('isJoiningをfalseに設定');
          setIsJoining(false);
        }
      }
    };

    initializeSession();

    // クリーンアップ
    return () => {
      cancelledRef.current = true;
      console.log('🧹 SessionView cleanup called');
      if (roomId && isConnected) {
        console.log('🚪 Leaving room in cleanup');
        leaveRoom(roomId);
      }

      // Ion-SFU cleanup
      if (ionSfuServiceRef.current) {
        console.log('🧹 Cleaning up Ion-SFU service');
        ionSfuServiceRef.current.cleanup();
        ionSfuServiceRef.current = null;
      }

      // Local stream cleanup
      if (localStream) {
        console.log('🧹 Stopping local stream tracks');
        localStream.getTracks().forEach(track => track.stop());
      }
      // Strict Modeでの重複実行を防ぐため、disconnectをコメントアウト
      // disconnect();
    };
  }, [roomId]); // roomIdのみ - 関数は依存配列から除外

  const handleLeaveRoom = () => {
    navigate('/');
  };

  // activeParticipantsは現在使用していないため削除

  const getConnectionStatusColor = () => {
    switch (connectionState) {
      case 'connected': return 'text-green-400';
      case 'connecting':
      case 'reconnecting': return 'text-yellow-400';
      case 'failed': return 'text-red-400';
      default: return 'text-gray-400';
    }
  };

  const getConnectionStatusText = () => {
    switch (connectionState) {
      case 'connected': return '接続済み';
      case 'connecting': return '接続中...';
      case 'reconnecting': return '再接続中...';
      case 'failed': return '接続失敗';
      case 'disconnected': return '切断済み';
      default: return '不明';
    }
  };

  if (isJoining) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="lg" color="white" className="mb-4" />
          <h2 className="text-xl font-semibold mb-2">セッション初期化中...</h2>
          <p className="text-gray-400">
            WebSocket接続とカメラを初期化しています
          </p>
          <div className="mt-2 text-sm">
            <span className={getConnectionStatusColor()}>
              ● {getConnectionStatusText()}
            </span>
          </div>
        </div>
      </div>
    );
  }

  if (joinError || mediaPipeError || signalingError) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
        <div className="text-center max-w-md">
          <div className="text-red-400 text-6xl mb-4">⚠️</div>
          <h2 className="text-xl font-semibold mb-2">接続エラー</h2>
          <p className="text-gray-400 mb-2">{joinError || mediaPipeError || signalingError}</p>
          <div className="text-sm text-gray-500 mb-6">
            接続状態: <span className={getConnectionStatusColor()}>{getConnectionStatusText()}</span>
          </div>
          <Button
            variant="primary"
            onClick={handleLeaveRoom}
          >
            ロビーに戻る
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 text-white">
      <div className="container mx-auto p-4">
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div>
            <h1 className="text-2xl font-bold">ルーム: {roomId}</h1>
            <div className="flex items-center gap-4 text-sm">
              <span className="text-gray-400">ユーザー: {userName}</span>
              {isBroadcaster !== undefined && (
                <span className={`${isBroadcaster ? 'text-blue-400' : 'text-purple-400'}`}>
                  {isBroadcaster ? '📡 配信者' : '👁️ 視聴者'}
                </span>
              )}
              <span className={`${getConnectionStatusColor()}`}>
                ● {getConnectionStatusText()}
              </span>
              {isBroadcaster && receivedReactions.length > 0 && (
                <span className="text-green-400">
                  💚 リアクション: {receivedReactions.length}件
                </span>
              )}
              {!isBroadcaster && hasTimestamp && (
                <span className="text-green-400">
                  ✓ 配信受信中
                </span>
              )}
            </div>
          </div>
          <Button
            variant="danger"
            onClick={handleLeaveRoom}
          >
            ルームを退出
          </Button>
        </div>

        {/* Main Content */}
        <div className="max-w-6xl mx-auto space-y-6">

          {/* ビデオプレビューエリア */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4 text-center">
              {isBroadcaster === true ? 'あなたの配信映像' : isBroadcaster === false ? '配信映像' : '映像'}
            </h2>
            <div className="flex justify-center">
              {/* 配信者用: ローカル映像 */}
              <video
                ref={localVideoRef}
                autoPlay
                muted
                playsInline
                className={`w-full max-w-2xl rounded bg-black ${isBroadcaster !== true ? 'hidden' : ''}`}
              />

              {/* 視聴者用: リモート映像 */}
              <video
                ref={remoteVideoRef}
                autoPlay
                playsInline
                className={`w-full max-w-2xl rounded bg-black ${isBroadcaster !== false ? 'hidden' : ''}`}
              />
            </div>
            {!isBroadcaster && !remoteVideoRef.current?.srcObject && (
              <p className="text-center text-gray-400 mt-4">
                配信者の映像を待っています...
              </p>
            )}
          </div>

          {/* 視聴者のみ: 自分のランドマーク表示エリア */}
          {!isBroadcaster && (
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-lg font-semibold mb-4 text-center">あなたの表情ランドマーク</h2>

              <div className="flex flex-col lg:flex-row gap-6 items-start">
                {/* 正規化後ランドマーク3D表示 */}
                <div className="flex-1 w-full max-w-md mx-auto">
                  {/* 視聴者用: MediaPipe処理用の非表示カメラ */}
                  <video
                    ref={viewerCameraRef}
                    autoPlay
                    muted
                    playsInline
                    className="hidden"
                  />

                  {/* 3Dビジュアライゼーション */}
                  <NormalizedLandmarksViewer
                    normalizedData={normalizationData}
                    width={Math.min(400, window.innerWidth - 60)}
                    height={Math.min(400, window.innerWidth - 60)}
                  />
                </div>

                {/* 自分の感情データとコントロール */}
                <div className="flex-1 space-y-4">
                  {/* 感情インジケーターとシステム情報は非表示 */}
                </div>
              </div>
            </div>
          )}

          {/* 配信者用: 受信したリアクション表示 */}
          {isBroadcaster && (
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-lg font-semibold mb-4">受信したリアクション</h2>

              {receivedReactions.length > 0 ? (
                <div className="space-y-3">
                  <div className="text-3xl font-bold text-green-400">
                    💚 {receivedReactions.length} 件
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-96 overflow-y-auto">
                    {receivedReactions.slice(-20).reverse().map((reaction, index) => (
                      <div key={index} className="bg-gray-700 rounded p-3 text-sm">
                        <div className="flex items-center justify-between mb-1">
                          <span className="font-medium text-blue-400">{reaction.data.userId}</span>
                          <span className="text-xs text-gray-400">
                            {new Date(reaction.data.reactionSentTime).toLocaleTimeString()}
                          </span>
                        </div>
                        <div className="text-2xl">💚</div>
                        <div className="mt-2 text-xs text-gray-400">
                          遅延: {reaction.metrics.broadcastToReceivedMs.toFixed(0)}ms
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (
                <div className="text-center py-8">
                  <div className="text-4xl mb-4">💚</div>
                  <h3 className="text-lg font-medium mb-2">リアクションを待機中</h3>
                  <p className="text-gray-400 text-sm">
                    視聴者からのリアクションがここに表示されます
                  </p>
                </div>
              )}
            </div>
          )}

          {/* 視聴者用: リアルタイム感情データ表示エリア */}
          {!isBroadcaster && (
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-lg font-semibold mb-4">リアルタイム感情データ</h2>

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {/* 受信した感情データのグラフ表示 */}
                {Array.from(receivedEmotions.entries()).map(([userId, emotions]) => (
                  <IntensityChart
                    key={userId}
                    emotionData={emotions}
                    userId={userId}
                    width={Math.min(400, window.innerWidth - 80)}
                    height={200}
                  />
                ))}

                {/* 感情データが無い場合の表示 */}
                {receivedEmotions.size === 0 && (
                  <div className="col-span-full text-center py-8">
                    <div className="text-4xl mb-4">📊</div>
                    <h3 className="text-lg font-medium mb-2">感情データを待機中</h3>
                    <p className="text-gray-400 text-sm">
                      バックエンドからの感情データを受信すると、リアルタイムグラフが表示されます
                    </p>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* 他の参加者の感情インジケーターは非表示 */}

          {/* システム情報は非表示 */}
        </div>
      </div>
    </div>
  );
};

