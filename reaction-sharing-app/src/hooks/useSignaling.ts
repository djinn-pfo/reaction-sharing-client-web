import { useState, useEffect, useCallback, useRef } from 'react';
import { useWebRTC } from '../contexts/WebRTCContext';
import { WebSocketClient, MessageHandler } from '../services/signaling';
import { config } from '../config/environment';
import type {
  ConnectionState,
  SignalingMessage,
  WebRTCSignalingMessage,
  PeerJoinedMessage,
  PeerLeftMessage,
  BroadcastTimestampMessage,
  EmotionWithTimestampMessage,
  RoomJoinedMessage,
} from '../types/signaling';

interface UseSignalingOptions {
  autoConnect?: boolean;
  onBroadcastTimestamp?: (message: BroadcastTimestampMessage) => void;
  onEmotionWithTimestamp?: (message: EmotionWithTimestampMessage) => void;
  onRoomJoined?: (message: RoomJoinedMessage) => void;
  onIonMessage?: (message: any) => void;
  enableWebRTC?: boolean; // Default: false (disabled for broadcast/viewer modes)
}

interface UseSignalingReturn {
  connectionState: ConnectionState;
  isConnected: boolean;
  error: string | null;
  receivedEmotions: Map<string, any[]>;
  connect: () => Promise<void>;
  disconnect: () => void;
  joinRoom: (roomId: string, username: string) => Promise<void>;
  leaveRoom: (roomId: string) => void;
  sendSignalingMessage: (message: SignalingMessage | any) => boolean;
  sendEmotionData: (landmarks: any[], userId: string, confidence?: number, normalizedLandmarks?: any[]) => boolean;
  sendBroadcastTimestamp: (message: BroadcastTimestampMessage) => boolean;
  sendEmotionWithTimestamp: (message: EmotionWithTimestampMessage) => boolean;
  getWebSocketState: () => ConnectionState | null;
  initiateWebRTCConnection: (peerId: string, peerUsername: string) => Promise<void>;
}

export const useSignaling = (options: UseSignalingOptions = {}): UseSignalingReturn => {
  const { autoConnect = false, onBroadcastTimestamp, onEmotionWithTimestamp, onRoomJoined, onIonMessage, enableWebRTC = false } = options;
  const { state: webrtcState, actions: webrtcActions } = useWebRTC();

  const [connectionState, setConnectionState] = useState<ConnectionState>('disconnected');
  const [error, setError] = useState<string | null>(null);
  const [currentRoomId, setCurrentRoomId] = useState<string | null>(null);
  const [currentUsername, setCurrentUsername] = useState<string | null>(null);
  const [receivedEmotions, setReceivedEmotions] = useState<Map<string, any[]>>(new Map());

  // connectionState„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ
  useEffect(() => {
    console.log('üìä React connectionState updated to:', connectionState);
  }, [connectionState]);

  const wsClientRef = useRef<WebSocketClient | null>(null);
  const messageHandlerRef = useRef<MessageHandler | null>(null);

  // ÊÑüÊÉÖ„Éá„Éº„Çø„Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„ÉàÂá¶ÁêÜ
  const handleEmotionBroadcast = useCallback((message: any) => {
    try {
      // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Åã„Çâ„ÅÆemotion.broadcastÂΩ¢Âºè
      // { type: "emotion.broadcast", from: "user_A", data: { userId, intensity, confidence, timestamp } }
      const emotionData = message.data;
      const userId = emotionData.userId || message.from;
      const timestamp = emotionData.timestamp || Date.now();
      const intensity = emotionData.intensity || 0;
      const confidence = emotionData.confidence || 0;
      const velocity = emotionData.velocity || 0;
      const features = emotionData.features || {};

      const newEmotion = {
        userId,
        timestamp,
        intensity: Math.abs(intensity), // Ë≤†„ÅÆÂÄ§„ÅÆÂ†¥Âêà„ÅØÁµ∂ÂØæÂÄ§„ÇíÂèñ„Çã
        laughLevel: Math.abs(intensity) > 70 ? 'high' : Math.abs(intensity) > 40 ? 'medium' : 'low',
        confidence,
        velocity,
        features
      };

      // Âèó‰ø°„Åó„ÅüÊÑüÊÉÖ„Éá„Éº„Çø„ÇíÁä∂ÊÖã„Å´‰øùÂ≠ò
      setReceivedEmotions(prev => {
        const newMap = new Map(prev);
        const userEmotions = newMap.get(userId) || [];

        const updatedEmotions = [...userEmotions, newEmotion].slice(-50);
        newMap.set(userId, updatedEmotions);

        return newMap;
      });

    } catch (error) {
      console.error('Failed to handle emotion broadcast:', error);
    }
  }, []);

  // ÊÑüÊÉÖÂá¶ÁêÜÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ
  const handleEmotionProcessed = useCallback((message: any) => {
    console.log('‚úÖ Emotion processing confirmed:', message.data.message);
  }, []);

  // „Éî„Ç¢ÂèÇÂä†Âá¶ÁêÜ
  const handlePeerJoined = useCallback(async (message: PeerJoinedMessage) => {
    // enableWebRTC„Ååfalse„ÅÆÂ†¥Âêà„ÅØWebRTCÊé•Á∂ö„Çí„Çπ„Ç≠„ÉÉ„Éó
    if (!enableWebRTC) {
      console.log('‚è≠Ô∏è Skipping WebRTC connection - enableWebRTC is false');
      return;
    }

    try {
      console.log('üë• [WebRTC] Peer joined:', message.peerId, message.username);
      console.log('üë• [WebRTC] Local stream available:', !!webrtcState.localStream);

      // „Éî„Ç¢Êé•Á∂ö„Çí‰ΩúÊàê
      const connection = await webrtcActions.createPeerConnection(message.peerId, message.username);
      console.log('‚úÖ [WebRTC] Peer connection created');

      // ICE candidateÈÄÅ‰ø°„Éè„É≥„Éâ„É©„Éº„ÇíË®≠ÂÆö
      connection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`üßä [WebRTC] Sending ICE candidate to peer ${message.peerId}`);
          const candidateMessage = MessageHandler.createIceCandidateMessage(
            currentUsername || 'anonymous',
            message.peerId,
            event.candidate.toJSON()
          );
          sendSignalingMessage(candidateMessage);
        }
      };

      // „Éá„Éº„Çø„ÉÅ„É£„Éç„É´„Çí‰ΩúÊàêÔºàÊÑüÊÉÖ„Éá„Éº„ÇøÂÖ±ÊúâÁî®Ôºâ
      const dataChannel = connection.createDataChannel('emotions', {
        ordered: false, // „É™„Ç¢„É´„Çø„Ç§„É†ÊÄß„ÇíÈáçË¶ñ
      });
      console.log('‚úÖ [WebRTC] Data channel created:', dataChannel.label);

      // „Éî„Ç¢„ÇíËøΩÂä†
      webrtcActions.addPeer(message.peerId, message.username, connection);
      console.log('‚úÖ [WebRTC] Peer added to state');

      // Offer„Çí‰ΩúÊàê„Åó„Å¶ÈÄÅ‰ø°
      const offer = await connection.createOffer();
      await connection.setLocalDescription(offer);
      console.log('‚úÖ [WebRTC] Offer created and local description set');

      const offerMessage = MessageHandler.createOfferMessage(
        currentUsername || 'anonymous',
        message.peerId,
        offer
      );

      const sendSuccess = sendSignalingMessage(offerMessage);
      console.log('üì§ [WebRTC] Offer message sent:', sendSuccess);

    } catch (error) {
      console.error('‚ùå [WebRTC] Failed to handle peer joined:', error);
      setError('„Éî„Ç¢Êé•Á∂ö„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  }, [webrtcActions, currentUsername, enableWebRTC, webrtcState.localStream]);

  // „Éî„Ç¢ÈÄÄÂá∫Âá¶ÁêÜ
  const handlePeerLeft = useCallback((message: PeerLeftMessage) => {
    console.log('Peer left:', message.peerId);
    webrtcActions.removePeer(message.peerId);
  }, [webrtcActions]);

  // WebRTC„Ç∑„Ç∞„Éä„É™„É≥„Ç∞Âá¶ÁêÜ
  const handleWebRTCSignaling = useCallback(async (message: WebRTCSignalingMessage) => {
    try {
      console.log('üîó Received WebRTC signaling:', message.type, 'from:', message.from);

      // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Åã„Çâ„ÅÆOffer„ÅÆÂ†¥Âêà„ÅØÊñ∞„Åó„ÅÑ„Éî„Ç¢Êé•Á∂ö„Çí‰ΩúÊàê
      if (((message as any).type === 'webrtc-offer' || message.type === 'offer') && message.from === 'backend') {
        console.log('üîó Creating new peer connection for backend');

        // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å®„ÅÆ„Éî„Ç¢Êé•Á∂ö„Çí‰ΩúÊàê
        const connection = await webrtcActions.createPeerConnection('backend', 'Backend Server');

        // Data Channel„ÅÆÂèó‰ø°Ê∫ñÂÇô
        connection.ondatachannel = (event) => {
          const dataChannel = event.channel;
          console.log('üì• Data channel received from backend:', dataChannel.label);

          // WebRTCContext„ÅÆsetupDataChannel„Çí‰ΩøÁî®
          webrtcActions.setupDataChannel?.(dataChannel, 'backend');
        };

        // „Éî„Ç¢„ÇíËøΩÂä†
        webrtcActions.addPeer('backend', 'Backend Server', connection);

        // Offer„ÇíË®≠ÂÆö
        const offerData = (message.data as any)?.offer || message.data;
        await connection.setRemoteDescription(offerData as RTCSessionDescriptionInit);

        // Answer„Çí‰ΩúÊàê„Åó„Å¶ÈÄÅ‰ø°
        const answer = await connection.createAnswer();
        await connection.setLocalDescription(answer);

        const answerMessage = {
          type: 'webrtc-answer',
          from: currentUsername || 'anonymous',
          to: 'backend',
          room: currentRoomId ?? undefined,
          data: {
            answer: answer,
            peerId: 'backend'
          },
          timestamp: Date.now()
        } as any;

        sendSignalingMessage(answerMessage);
        console.log('‚úÖ Sent answer to backend');
        return;
      }

      // Êó¢Â≠ò„ÅÆ„Éî„Ç¢Êé•Á∂ö„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆÂá¶ÁêÜ
      const peer = webrtcState.peers.get(message.from);
      if (!peer) {
        console.warn('Received signaling for unknown peer:', message.from);
        return;
      }

      const { connection } = peer;

      switch (message.type) {
        case 'offer':
        case 'webrtc-offer' as any:
          // Offer„ÇíÂèó‰ø°
          console.log('üì• [WebRTC] Received offer from:', message.from);

          // ICE candidateÈÄÅ‰ø°„Éè„É≥„Éâ„É©„Éº„ÇíË®≠ÂÆöÔºàanswererÂÅ¥Ôºâ
          connection.onicecandidate = (event) => {
            if (event.candidate) {
              console.log(`üßä [WebRTC] Sending ICE candidate to peer ${message.from}`);
              const candidateMessage = MessageHandler.createIceCandidateMessage(
                currentUsername || 'anonymous',
                message.from,
                event.candidate.toJSON()
              );
              sendSignalingMessage(candidateMessage);
            }
          };

          const offerData = (message.data as any)?.offer || message.data;
          await connection.setRemoteDescription(offerData as RTCSessionDescriptionInit);
          console.log('‚úÖ [WebRTC] Remote description set (offer)');

          // Answer„Çí‰ΩúÊàê„Åó„Å¶ÈÄÅ‰ø°
          const answer = await connection.createAnswer();
          await connection.setLocalDescription(answer);
          console.log('‚úÖ [WebRTC] Answer created and local description set');

          const answerMessage = MessageHandler.createAnswerMessage(
            currentUsername || 'anonymous',
            message.from,
            answer
          );

          const answerSent = sendSignalingMessage(answerMessage);
          console.log('üì§ [WebRTC] Answer sent:', answerSent);
          break;

        case 'answer':
        case 'webrtc-answer' as any:
          // Answer„ÇíÂèó‰ø°
          console.log('üì• [WebRTC] Received answer from:', message.from);
          const answerData = (message.data as any)?.answer || message.data;
          await connection.setRemoteDescription(answerData as RTCSessionDescriptionInit);
          console.log('‚úÖ [WebRTC] Remote description set (answer)');
          break;

        case 'ice-candidate':
          // ICEÂÄôË£ú„ÇíÂèó‰ø°
          console.log('üì• [WebRTC] Received ICE candidate from:', message.from);
          const candidateData = (message.data as any)?.candidate || message.data;
          const candidate = new RTCIceCandidate(candidateData as RTCIceCandidateInit);
          await connection.addIceCandidate(candidate);
          console.log('‚úÖ [WebRTC] ICE candidate added');
          break;
      }
    } catch (error) {
      console.error('Failed to handle WebRTC signaling:', error);
      setError('WebRTC„Ç∑„Ç∞„Éä„É™„É≥„Ç∞„ÅÆÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
  }, [webrtcState.peers, currentUsername, currentRoomId, webrtcActions]);

  // Êé•Á∂ö
  const connect = useCallback(async () => {
    try {
      console.log('üì° connect() called - attempting WebSocket connection...');
      console.log('üîç wsClientRef.current:', wsClientRef.current);
      console.log('üîç Current connectionState:', connectionState);

      if (!wsClientRef.current) {
        throw new Error('WebSocket client not initialized');
      }

      // ÁèæÂú®„ÅÆWebSocketÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
      const currentState = wsClientRef.current.getConnectionState();
      console.log('üîç WebSocket client state before connect:', currentState);

      setError(null);
      console.log('üöÄ Calling wsClientRef.current.connect()...');
      await wsClientRef.current.connect();

      // Êé•Á∂öÂæå„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
      const newState = wsClientRef.current.getConnectionState();
      console.log('‚úÖ wsClientRef.current.connect() completed successfully');
      console.log('üîç WebSocket client state after connect:', newState);
    } catch (error) {
      console.error('‚ùå Failed to connect to signaling server:', error);
      setError('„Ç∑„Ç∞„Éä„É™„É≥„Ç∞„Çµ„Éº„Éê„Éº„Å∏„ÅÆÊé•Á∂ö„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
      throw error;
    }
  }, [connectionState]);

  // ÂàáÊñ≠
  const disconnect = useCallback(() => {
    console.log('üîå disconnect() called');
    if (wsClientRef.current) {
      console.log('üîç WebSocket state before disconnect:', wsClientRef.current.getConnectionState());
      wsClientRef.current.disconnect();
    }
    webrtcActions.cleanup();
    setCurrentRoomId(null);
    setCurrentUsername(null);
  }, [webrtcActions]);

  // „É´„Éº„É†ÂèÇÂä†
  const joinRoom = useCallback(async (roomId: string, username: string) => {
    try {
      console.log('üè† joinRoomÈñãÂßã:', { roomId, username, connectionState, wsClient: !!wsClientRef.current });

      if (!wsClientRef.current) {
        throw new Error('WebSocket client not initialized');
      }

      // üîß Á∑äÊÄ•‰øÆÊ≠£: connectionState„ÅÆ‰ª£„Çè„Çä„Å´WebSocket„ÅÆÁä∂ÊÖã„ÇíÁõ¥Êé•„ÉÅ„Çß„ÉÉ„ÇØ
      const wsState = wsClientRef.current.getConnectionState();
      console.log('üîç WebSocketÁä∂ÊÖã:', wsState);

      if (wsState !== 'connected') {
        throw new Error(`WebSocket not connected, state: ${wsState}`);
      }

      // WebRTC„ÇíÂàùÊúüÂåñ
      await webrtcActions.initializeWebRTC();

      // „É´„Éº„É†ÂèÇÂä†„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
      console.log('üì§ „É´„Éº„É†ÂèÇÂä†„É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàê‰∏≠...');
      const joinMessage = MessageHandler.createJoinRoomMessage(roomId, username);
      console.log('üì§ ÈÄÅ‰ø°„É°„ÉÉ„Çª„Éº„Ç∏:', joinMessage);

      const success = sendSignalingMessage(joinMessage);
      console.log('üì§ „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°ÁµêÊûú:', success);

      if (!success) {
        throw new Error('Failed to send join room message');
      }

      setCurrentRoomId(roomId);
      setCurrentUsername(username);
      setError(null);

      // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å®„ÅÆWebRTCÊé•Á∂ö„ÇíÈñãÂßãÔºàÈÄöÂ∏∏„É¢„Éº„Éâ„ÅÆ„ÅøÔºâ
      if (enableWebRTC) {
        console.log('üîó „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å®„ÅÆWebRTCÊé•Á∂ö„ÇíÈñãÂßã...');
        const startPeerMessage = {
          type: 'start-peer-connection',
          data: {
            remoteUserId: 'backend' // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å®„ÅÆÊé•Á∂ö
          },
          timestamp: Date.now()
        };

        const peerSuccess = sendSignalingMessage(startPeerMessage);
        console.log('üîó WebRTCÊé•Á∂öÈñãÂßã„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°ÁµêÊûú:', peerSuccess);
      } else {
        console.log('üîó WebRTC disabled (broadcast/viewer mode)');
      }

    } catch (error) {
      console.error('‚ùå Failed to join room:', error);
      setError(`„É´„Éº„É†ÂèÇÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  }, [connectionState, webrtcActions]);

  // „É´„Éº„É†ÈÄÄÂá∫
  const leaveRoom = useCallback((roomId: string) => {
    if (wsClientRef.current && currentRoomId === roomId) {
      const leaveMessage = MessageHandler.createLeaveRoomMessage(roomId);
      sendSignalingMessage(leaveMessage);

      webrtcActions.cleanup();
      setCurrentRoomId(null);
      setCurrentUsername(null);
    }
  }, [currentRoomId, webrtcActions]);

  // „Ç∑„Ç∞„Éä„É™„É≥„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
  const sendSignalingMessage = useCallback((message: SignalingMessage): boolean => {
    if (!wsClientRef.current) {
      console.warn('WebSocket client not initialized');
      return false;
    }

    return wsClientRef.current.send(message);
  }, []);


  // ÊÑüÊÉÖ„Éá„Éº„ÇøÈÄÅ‰ø°ÔºàWebSocket APIÊ∫ñÊã†Ôºâ
  const sendEmotionData = useCallback((landmarks: any[], userId: string, confidence: number = 0.9, normalizedLandmarks?: any[]): boolean => {
    if (!wsClientRef.current || !currentRoomId) {
      console.warn('Cannot send emotion data: WebSocket not connected or not in room');
      return false;
    }

    // Ê≠£Ë¶èÂåñ„Åï„Çå„Åü„É©„É≥„Éâ„Éû„Éº„ÇØ„Åå„ÅÇ„Çå„Å∞„Åù„Çå„ÇíÂÑ™ÂÖà„ÄÅ„Å™„Åë„Çå„Å∞ÂÖÉ„ÅÆ„É©„É≥„Éâ„Éû„Éº„ÇØ„Çí‰ΩøÁî®
    const landmarksToSend = normalizedLandmarks && normalizedLandmarks.length > 0 ? normalizedLandmarks : landmarks;

    if (!landmarksToSend || landmarksToSend.length === 0) {
      console.warn('No landmarks to send');
      return false;
    }

    // Ê≠£Ë¶èÂåñ„Åï„Çå„Åü„É©„É≥„Éâ„Éû„Éº„ÇØ„Éá„Éº„Çø„ÇíÈÄÅ‰ø°
    const emotionMessage = {
      type: 'emotion',
      room: currentRoomId ?? undefined,
      data: {
        landmarks: flattenLandmarks(landmarksToSend),
        confidence: confidence,
        type: 'normalized-mediapipe', // Ê≠£Ë¶èÂåñÊ∏à„Åø„ÇíÁ§∫„Åô„Éï„É©„Ç∞
        isNormalized: !!normalizedLandmarks // Ê≠£Ë¶èÂåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„Åã„ÅÆÊòéÁ§∫ÁöÑ„Å™„Éï„É©„Ç∞
      },
      timestamp: Date.now()
    };

    console.log('üì§ Sending emotion data via WebSocket:', {
      userId,
      originalLandmarkCount: landmarks.length,
      normalizedLandmarkCount: normalizedLandmarks?.length || 0,
      isNormalized: !!normalizedLandmarks,
      confidence,
      room: currentRoomId
    });

    console.log('üì¶ Full emotion message:', emotionMessage);

    return sendSignalingMessage(emotionMessage);
  }, [currentRoomId]);

  // „É©„É≥„Éâ„Éû„Éº„ÇØ„ÇíÂπ≥Âù¶ÂåñÔºàAPI„ÅÆÂΩ¢Âºè„Å´Âêà„Çè„Åõ„Å¶Ôºâ
  const flattenLandmarks = useCallback((landmarks: any[]): number[] => {
    const flattened: number[] = [];
    landmarks.forEach(landmark => {
      flattened.push(landmark.x || 0, landmark.y || 0, landmark.z || 0);
    });
    return flattened;
  }, []);

  // WebSocket „ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
  const getWebSocketState = useCallback((): ConnectionState | null => {
    return wsClientRef.current?.getConnectionState() || null;
  }, []);

  // ÈÖç‰ø°„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„ÇíÈÄÅ‰ø°
  const sendBroadcastTimestamp = useCallback((message: BroadcastTimestampMessage): boolean => {
    const wsState = wsClientRef.current?.getConnectionState();
    if (!wsClientRef.current || wsState !== 'connected') {
      console.warn('Cannot send broadcast timestamp: WebSocket not connected', { wsState, connectionState });
      return false;
    }

    const success = wsClientRef.current.send(message);
    if (success) {
      console.log('üì° Sent broadcast timestamp:', message.data.frameId.slice(0, 8));
    }
    return success;
  }, [connectionState]);

  // „Çø„Ç§„É†„Çπ„Çø„É≥„Éó‰ªò„ÅçÊÑüÊÉÖ„Éá„Éº„Çø„ÇíÈÄÅ‰ø°
  const sendEmotionWithTimestamp = useCallback((message: EmotionWithTimestampMessage): boolean => {
    const wsState = wsClientRef.current?.getConnectionState();
    if (!wsClientRef.current || wsState !== 'connected') {
      console.warn('Cannot send emotion with timestamp: WebSocket not connected', { wsState, connectionState });
      return false;
    }

    const success = wsClientRef.current.send(message);
    if (success) {
      console.log('üé≠ Sent emotion with timestamp:', message.data.frameId.slice(0, 8));
    }
    return success;
  }, [connectionState]);

  // ÊâãÂãï„ÅßWebRTCÊé•Á∂ö„ÇíÈñãÂßãÔºàpeer-joined„É°„ÉÉ„Çª„Éº„Ç∏„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ‰ª£ÊõøÔºâ
  const initiateWebRTCConnection = useCallback(async (peerId: string, peerUsername: string) => {
    if (!enableWebRTC) {
      console.log('‚è≠Ô∏è Skipping manual WebRTC connection - enableWebRTC is false');
      return;
    }

    console.log('üîó [Manual] Initiating WebRTC connection to peer:', peerId, peerUsername);

    // handlePeerJoined„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÆüË°å
    const fakePeerJoinedMessage: PeerJoinedMessage = {
      type: 'peer-joined',
      peerId,
      username: peerUsername,
      timestamp: Date.now(),
    };

    await handlePeerJoined(fakePeerJoinedMessage);
  }, [enableWebRTC, handlePeerJoined]);

  // WebSocket„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å®„É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº„ÅÆÂàùÊúüÂåñ
  useEffect(() => {
    // React Strict Mode„Åß„ÅÆÈáçË§áÂÆüË°å„ÇíÈò≤„Åê
    if (wsClientRef.current) {
      console.log('WebSocket client already exists, skipping initialization');
      return;
    }

    // „É¶„Éº„Ç∂„ÉºID„ÇíÂèñÂæóÔºàlocalStorage„Åã„ÇâÔºâ
    const userId = localStorage.getItem('userName') || 'Anonymous';

    // WebSocket„ÇØ„É©„Ç§„Ç¢„É≥„Éà‰ΩúÊàê
    console.log('Creating WebSocket with userId:', userId);
    wsClientRef.current = new WebSocketClient({
      url: config.signalingUrl,
      userId: userId,
      reconnectInterval: 5000,
      maxReconnectAttempts: 1,
      heartbeatInterval: 0,
    });

    // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº‰ΩúÊàê
    messageHandlerRef.current = new MessageHandler();

    // WebSocket„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÉºË®≠ÂÆö
    wsClientRef.current.setEventHandlers({
      onOpen: () => {
        console.log('Signaling connected');
        setError(null);
      },
      onClose: () => {
        console.log('Signaling disconnected');
      },
      onError: (error) => {
        console.error('Signaling error:', error);
        setError('„Ç∑„Ç∞„Éä„É™„É≥„Ç∞„Çµ„Éº„Éê„Éº„Å®„ÅÆÊé•Á∂ö„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü');
      },
      onMessage: (message) => {
        messageHandlerRef.current?.handleMessage(message);
      },
      onConnectionStateChange: (state) => {
        console.log('üîÑ Connection state changed to:', state);
        setConnectionState(state);
      },
    });

    // „É°„ÉÉ„Çª„Éº„Ç∏„Éè„É≥„Éâ„É©„Éº„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØË®≠ÂÆö
    console.log('üîß [DEBUG] Setting up message handler callbacks:', {
      hasOnRoomJoined: !!onRoomJoined,
      hasOnBroadcastTimestamp: !!onBroadcastTimestamp,
      hasOnEmotionWithTimestamp: !!onEmotionWithTimestamp,
      hasOnIonMessage: !!onIonMessage,
      hasHandlePeerJoined: !!handlePeerJoined
    });
    messageHandlerRef.current.setCallbacks({
      onPeerJoined: handlePeerJoined,
      onPeerLeft: handlePeerLeft,
      onWebRTCSignaling: handleWebRTCSignaling,
      onEmotionBroadcast: handleEmotionBroadcast,
      onEmotionProcessed: handleEmotionProcessed,
      onBroadcastTimestamp: onBroadcastTimestamp,
      onEmotionWithTimestamp: onEmotionWithTimestamp,
      onIonMessage: onIonMessage,
      onRoomJoined: onRoomJoined,
      onError: (errorMessage) => {
        setError(errorMessage.error.message);
      },
    });
    console.log('‚úÖ [DEBUG] Message handler callbacks set');

    // Ëá™ÂãïÊé•Á∂ö
    if (autoConnect) {
      connect();
    }

    return () => {
      wsClientRef.current?.disconnect();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoConnect]);

  // Update callbacks when they change (from props only)
  useEffect(() => {
    console.log('üîÑ [DEBUG] Updating callbacks (prop change detected):', {
      hasOnRoomJoined: !!onRoomJoined,
      hasOnBroadcastTimestamp: !!onBroadcastTimestamp,
      hasOnEmotionWithTimestamp: !!onEmotionWithTimestamp,
      hasOnIonMessage: !!onIonMessage,
      hasMessageHandler: !!messageHandlerRef.current
    });

    if (messageHandlerRef.current) {
      messageHandlerRef.current.setCallbacks({
        onPeerJoined: handlePeerJoined,
        onPeerLeft: handlePeerLeft,
        onWebRTCSignaling: handleWebRTCSignaling,
        onEmotionBroadcast: handleEmotionBroadcast,
        onEmotionProcessed: handleEmotionProcessed,
        onBroadcastTimestamp: onBroadcastTimestamp,
        onEmotionWithTimestamp: onEmotionWithTimestamp,
        onIonMessage: onIonMessage,
        onRoomJoined: onRoomJoined,
        onError: (errorMessage) => {
          setError(errorMessage.error.message);
        },
      });
      console.log('‚úÖ [DEBUG] Callbacks updated via useEffect');
    }
    // Only re-run when prop callbacks change, not internal handlers
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onBroadcastTimestamp, onEmotionWithTimestamp, onRoomJoined, onIonMessage]);

  return {
    connectionState,
    isConnected: connectionState === 'connected',
    error,
    receivedEmotions,
    connect,
    disconnect,
    joinRoom,
    leaveRoom,
    sendSignalingMessage,
    sendEmotionData,
    sendBroadcastTimestamp,
    sendEmotionWithTimestamp,
    getWebSocketState,
    initiateWebRTCConnection,
  };
};